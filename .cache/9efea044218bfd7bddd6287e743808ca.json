{"dependencies":[{"name":"@firebase/webchannel-wrapper","loc":{"line":18,"column":35}},{"name":"../core/version","loc":{"line":19,"column":24}},{"name":"../remote/rpc_error","loc":{"line":20,"column":26}},{"name":"../remote/stream_bridge","loc":{"line":21,"column":30}},{"name":"../util/assert","loc":{"line":22,"column":23}},{"name":"../util/error","loc":{"line":23,"column":22}},{"name":"../util/log","loc":{"line":24,"column":18}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar webchannel_wrapper_1 = require(\"@firebase/webchannel-wrapper\");\nvar version_1 = require(\"../core/version\");\nvar rpc_error_1 = require(\"../remote/rpc_error\");\nvar stream_bridge_1 = require(\"../remote/stream_bridge\");\nvar assert_1 = require(\"../util/assert\");\nvar error_1 = require(\"../util/error\");\nvar log = require(\"../util/log\");\nvar LOG_TAG = 'Connection';\nvar RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';\nvar RPC_URL_VERSION = 'v1beta1';\n/** Maps RPC names to the corresponding REST endpoint name. */\nvar RPC_NAME_REST_MAPPING = {\n    BatchGetDocuments: 'batchGet',\n    Commit: 'commit'\n};\n// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because\n// we are doing out-of-band releases. Once we release as part of Firebase, we\n// should use the Firebase version instead.\nvar X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + version_1.SDK_VERSION;\nvar XHR_TIMEOUT_SECS = 15;\nvar WebChannelConnection = /** @class */ (function () {\n    function WebChannelConnection(info) {\n        this.databaseId = info.databaseId;\n        this.pool = new webchannel_wrapper_1.XhrIoPool();\n        var proto = info.ssl ? 'https' : 'http';\n        this.baseUrl = proto + '://' + info.host;\n    }\n    /**\n     * Modifies the headers for a request, adding any authorization token if\n     * present and any additional headers for the request.\n     */\n    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {\n        if (token) {\n            for (var header in token.authHeaders) {\n                if (token.authHeaders.hasOwnProperty(header)) {\n                    headers[header] = token.authHeaders[header];\n                }\n            }\n        }\n        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;\n        // This header is used to improve routing and project isolation by the\n        // backend.\n        headers['google-cloud-resource-prefix'] =\n            \"projects/\" + this.databaseId.projectId + \"/\" +\n                (\"databases/\" + this.databaseId.database);\n    };\n    WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {\n        var _this = this;\n        var url = this.makeUrl(rpcName);\n        return new Promise(function (resolve, reject) {\n            _this.pool.getObject(function (xhr) {\n                xhr.listenOnce(webchannel_wrapper_1.EventType.COMPLETE, function () {\n                    try {\n                        switch (xhr.getLastErrorCode()) {\n                            case webchannel_wrapper_1.ErrorCode.NO_ERROR:\n                                var json = xhr.getResponseJson();\n                                log.debug(LOG_TAG, 'XHR received:', JSON.stringify(json));\n                                resolve(json);\n                                break;\n                            case webchannel_wrapper_1.ErrorCode.TIMEOUT:\n                                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" timed out');\n                                reject(new error_1.FirestoreError(error_1.Code.DEADLINE_EXCEEDED, 'Request time out'));\n                                break;\n                            case webchannel_wrapper_1.ErrorCode.HTTP_ERROR:\n                                var status_1 = xhr.getStatus();\n                                log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed with status:', status_1, 'response text:', xhr.getResponseText());\n                                if (status_1 > 0) {\n                                    reject(new error_1.FirestoreError(rpc_error_1.mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));\n                                }\n                                else {\n                                    // If we received an HTTP_ERROR but there's no status code,\n                                    // it's most probably a connection issue\n                                    log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" failed');\n                                    reject(new error_1.FirestoreError(error_1.Code.UNAVAILABLE, 'Connection failed.'));\n                                }\n                                break;\n                            default:\n                                assert_1.fail('RPC \"' +\n                                    rpcName +\n                                    '\" failed with unanticipated ' +\n                                    'webchannel error ' +\n                                    xhr.getLastErrorCode() +\n                                    ': ' +\n                                    xhr.getLastError() +\n                                    ', giving up.');\n                        }\n                    }\n                    finally {\n                        log.debug(LOG_TAG, 'RPC \"' + rpcName + '\" completed.');\n                        _this.pool.releaseObject(xhr);\n                    }\n                });\n                var requestString = JSON.stringify(request);\n                log.debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);\n                // Content-Type: text/plain will avoid preflight requests which might\n                // mess with CORS and redirects by proxies. If we add custom headers\n                // we will need to change this code to potentially use the\n                // $httpOverwrite parameter supported by ESF to avoid\n                // triggering preflight requests.\n                var headers = { 'Content-Type': 'text/plain' };\n                _this.modifyHeadersForRequest(headers, token);\n                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);\n            });\n        });\n    };\n    WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {\n        // The REST API automatically aggregates all of the streamed results, so we\n        // can just use the normal invoke() method.\n        return this.invokeRPC(rpcName, request, token);\n    };\n    WebChannelConnection.prototype.openStream = function (rpcName, token) {\n        var urlParts = [\n            this.baseUrl,\n            '/',\n            RPC_STREAM_SERVICE,\n            '/',\n            rpcName,\n            '/channel'\n        ];\n        var webchannelTransport = webchannel_wrapper_1.createWebChannelTransport();\n        var request = {\n            // Background channel test avoids the initial two test calls and decreases\n            // initial cold start time.\n            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and\n            // we should monitor closely for any reports.\n            backgroundChannelTest: true,\n            // Required for backend stickiness, routing behavior is based on this\n            // parameter.\n            httpSessionIdParam: 'gsessionid',\n            initMessageHeaders: {},\n            // Send our custom headers as a '$httpHeaders=' url param to avoid CORS\n            // preflight round-trip. This is formally defined here:\n            // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40\n            httpHeadersOverwriteParam: '$httpHeaders',\n            sendRawJson: true,\n            supportsCrossDomainXhr: true\n        };\n        this.modifyHeadersForRequest(request.initMessageHeaders, token);\n        var url = urlParts.join('');\n        log.debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);\n        // tslint:disable-next-line:no-any Because listen isn't defined on it.\n        var channel = webchannelTransport.createWebChannel(url, request);\n        // WebChannel supports sending the first message with the handshake - saving\n        // a network round trip. However, it will have to call send in the same\n        // JS event loop as open. In order to enforce this, we delay actually\n        // opening the WebChannel until send is called. Whether we have called\n        // open is tracked with this variable.\n        var opened = false;\n        // A flag to determine whether the stream was closed (by us or through an\n        // error/close event) to avoid delivering multiple close events or sending\n        // on a closed stream\n        var closed = false;\n        // tslint:disable-next-line:no-any\n        var streamBridge = new stream_bridge_1.StreamBridge({\n            sendFn: function (msg) {\n                if (!closed) {\n                    if (!opened) {\n                        log.debug(LOG_TAG, 'Opening WebChannel transport.');\n                        channel.open();\n                        opened = true;\n                    }\n                    log.debug(LOG_TAG, 'WebChannel sending:', msg);\n                    channel.send(msg);\n                }\n                else {\n                    log.debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);\n                }\n            },\n            closeFn: function () { return channel.close(); }\n        });\n        // Closure events are guarded and exceptions are swallowed, so catch any\n        // exception and rethrow using a setTimeout so they become visible again.\n        // Note that eventually this function could go away if we are confident\n        // enough the code is exception free.\n        var unguardedEventListen = function (type, fn) {\n            // TODO(dimond): closure typing seems broken because WebChannel does\n            // not implement goog.events.Listenable\n            channel.listen(type, function (param) {\n                try {\n                    fn(param);\n                }\n                catch (e) {\n                    setTimeout(function () {\n                        throw e;\n                    }, 0);\n                }\n            });\n        };\n        unguardedEventListen(webchannel_wrapper_1.WebChannel.EventType.OPEN, function () {\n            if (!closed) {\n                log.debug(LOG_TAG, 'WebChannel transport opened.');\n            }\n        });\n        unguardedEventListen(webchannel_wrapper_1.WebChannel.EventType.CLOSE, function () {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport closed');\n                streamBridge.callOnClose();\n            }\n        });\n        unguardedEventListen(webchannel_wrapper_1.WebChannel.EventType.ERROR, function (err) {\n            if (!closed) {\n                closed = true;\n                log.debug(LOG_TAG, 'WebChannel transport errored:', err);\n                streamBridge.callOnClose(new error_1.FirestoreError(error_1.Code.UNAVAILABLE, 'The operation could not be completed'));\n            }\n        });\n        unguardedEventListen(webchannel_wrapper_1.WebChannel.EventType.MESSAGE, function (msg) {\n            if (!closed) {\n                // WebChannel delivers message events as array. If batching\n                // is not enabled (it's off by default) each message will be\n                // delivered alone, resulting in a single element array.\n                var msgData = msg.data[0];\n                assert_1.assert(!!msgData, 'Got a webchannel message without data.');\n                // TODO(b/35143891): There is a bug in One Platform that caused errors\n                // (and only errors) to be wrapped in an extra array. To be forward\n                // compatible with the bug we need to check either condition. The latter\n                // can be removed once the fix has been rolled out.\n                var error = msgData.error || (msgData[0] && msgData[0].error);\n                if (error) {\n                    log.debug(LOG_TAG, 'WebChannel received error:', error);\n                    // error.status will be a string like 'OK' or 'NOT_FOUND'.\n                    var status_2 = error.status;\n                    var code = rpc_error_1.mapCodeFromRpcStatus(status_2);\n                    var message = error.message;\n                    if (code === undefined) {\n                        code = error_1.Code.INTERNAL;\n                        message =\n                            'Unknown error status: ' +\n                                status_2 +\n                                ' with message ' +\n                                error.message;\n                    }\n                    // Mark closed so no further events are propagated\n                    closed = true;\n                    streamBridge.callOnClose(new error_1.FirestoreError(code, message));\n                    channel.close();\n                }\n                else {\n                    log.debug(LOG_TAG, 'WebChannel received:', msgData);\n                    streamBridge.callOnMessage(msgData);\n                }\n            }\n        });\n        setTimeout(function () {\n            // Technically we could/should wait for the WebChannel opened event,\n            // but because we want to send the first message with the WebChannel\n            // handshake we pretend the channel opened here (asynchronously), and\n            // then delay the actual open until the first message is sent.\n            streamBridge.callOnOpen();\n        }, 0);\n        return streamBridge;\n    };\n    // visible for testing\n    WebChannelConnection.prototype.makeUrl = function (rpcName) {\n        var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];\n        assert_1.assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);\n        var url = [this.baseUrl, '/', RPC_URL_VERSION];\n        url.push('/projects/');\n        url.push(this.databaseId.projectId);\n        url.push('/databases/');\n        url.push(this.databaseId.database);\n        url.push('/documents');\n        url.push(':');\n        url.push(urlRpcName);\n        return url.join('');\n    };\n    return WebChannelConnection;\n}());\nexports.WebChannelConnection = WebChannelConnection;\n\n//# sourceMappingURL=webchannel_connection.js.map\n"},"hash":"13824a2c85f88c0d0cd17bb314169e9d"}