{"dependencies":[{"name":"../util/assert","loc":{"line":18,"column":23}},{"name":"../util/error","loc":{"line":19,"column":22}},{"name":"../util/log","loc":{"line":20,"column":18}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"../util/assert\");\nvar error_1 = require(\"../util/error\");\nvar log = require(\"../util/log\");\n/**\n * Error Codes describing the different ways GRPC can fail. These are copied\n * directly from GRPC's sources here:\n *\n * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h\n *\n * Important! The names of these identifiers matter because the string forms\n * are used for reverse lookups from the webchannel stream. Do NOT change the\n * names of these identifiers.\n */\nvar RpcCode;\n(function (RpcCode) {\n    RpcCode[RpcCode[\"OK\"] = 0] = \"OK\";\n    RpcCode[RpcCode[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    RpcCode[RpcCode[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    RpcCode[RpcCode[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    RpcCode[RpcCode[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    RpcCode[RpcCode[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    RpcCode[RpcCode[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    RpcCode[RpcCode[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    RpcCode[RpcCode[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n    RpcCode[RpcCode[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    RpcCode[RpcCode[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    RpcCode[RpcCode[\"ABORTED\"] = 10] = \"ABORTED\";\n    RpcCode[RpcCode[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    RpcCode[RpcCode[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    RpcCode[RpcCode[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    RpcCode[RpcCode[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    RpcCode[RpcCode[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n})(RpcCode || (RpcCode = {}));\nfunction isPermanentError(code) {\n    switch (code) {\n        case error_1.Code.OK:\n            return assert_1.fail('Treated status OK as error');\n        case error_1.Code.CANCELLED:\n        case error_1.Code.UNKNOWN:\n        case error_1.Code.DEADLINE_EXCEEDED:\n        case error_1.Code.RESOURCE_EXHAUSTED:\n        case error_1.Code.INTERNAL:\n        case error_1.Code.UNAVAILABLE:\n        // Unauthenticated means something went wrong with our token and we need\n        // to retry with new credentials which will happen automatically.\n        // TODO(b/37325376): Give up after second unauthenticated error.\n        case error_1.Code.UNAUTHENTICATED:\n            return false;\n        case error_1.Code.INVALID_ARGUMENT:\n        case error_1.Code.NOT_FOUND:\n        case error_1.Code.ALREADY_EXISTS:\n        case error_1.Code.PERMISSION_DENIED:\n        case error_1.Code.FAILED_PRECONDITION:\n        // Aborted might be retried in some scenarios, but that is dependant on\n        // the context and should handled individually by the calling code.\n        // See https://cloud.google.com/apis/design/errors.\n        case error_1.Code.ABORTED:\n        case error_1.Code.OUT_OF_RANGE:\n        case error_1.Code.UNIMPLEMENTED:\n        case error_1.Code.DATA_LOSS:\n            return true;\n        default:\n            return assert_1.fail('Unknown status code: ' + code);\n    }\n}\nexports.isPermanentError = isPermanentError;\n/**\n * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.\n *\n * @returns The Code equivalent to the given status string or undefined if\n *     there is no match.\n */\nfunction mapCodeFromRpcStatus(status) {\n    // tslint:disable-next-line:no-any lookup by string\n    var code = RpcCode[status];\n    if (code === undefined) {\n        return undefined;\n    }\n    return mapCodeFromRpcCode(code);\n}\nexports.mapCodeFromRpcStatus = mapCodeFromRpcStatus;\n/**\n * Maps an error Code from GRPC status code number, like 0, 1, or 14. These\n * are not the same as HTTP status codes.\n *\n * @returns The Code equivalent to the given GRPC status code. Fails if there\n *     is no match.\n */\nfunction mapCodeFromRpcCode(code) {\n    if (code === undefined) {\n        // This shouldn't normally happen, but in certain error cases (like trying\n        // to send invalid proto messages) we may get an error with no GRPC code.\n        log.error('GRPC error has no .code');\n        return error_1.Code.UNKNOWN;\n    }\n    switch (code) {\n        case RpcCode.OK:\n            return error_1.Code.OK;\n        case RpcCode.CANCELLED:\n            return error_1.Code.CANCELLED;\n        case RpcCode.UNKNOWN:\n            return error_1.Code.UNKNOWN;\n        case RpcCode.DEADLINE_EXCEEDED:\n            return error_1.Code.DEADLINE_EXCEEDED;\n        case RpcCode.RESOURCE_EXHAUSTED:\n            return error_1.Code.RESOURCE_EXHAUSTED;\n        case RpcCode.INTERNAL:\n            return error_1.Code.INTERNAL;\n        case RpcCode.UNAVAILABLE:\n            return error_1.Code.UNAVAILABLE;\n        case RpcCode.UNAUTHENTICATED:\n            return error_1.Code.UNAUTHENTICATED;\n        case RpcCode.INVALID_ARGUMENT:\n            return error_1.Code.INVALID_ARGUMENT;\n        case RpcCode.NOT_FOUND:\n            return error_1.Code.NOT_FOUND;\n        case RpcCode.ALREADY_EXISTS:\n            return error_1.Code.ALREADY_EXISTS;\n        case RpcCode.PERMISSION_DENIED:\n            return error_1.Code.PERMISSION_DENIED;\n        case RpcCode.FAILED_PRECONDITION:\n            return error_1.Code.FAILED_PRECONDITION;\n        case RpcCode.ABORTED:\n            return error_1.Code.ABORTED;\n        case RpcCode.OUT_OF_RANGE:\n            return error_1.Code.OUT_OF_RANGE;\n        case RpcCode.UNIMPLEMENTED:\n            return error_1.Code.UNIMPLEMENTED;\n        case RpcCode.DATA_LOSS:\n            return error_1.Code.DATA_LOSS;\n        default:\n            return assert_1.fail('Unknown status code: ' + code);\n    }\n}\nexports.mapCodeFromRpcCode = mapCodeFromRpcCode;\n/**\n * Maps an RPC code from a Code. This is the reverse operation from\n * mapCodeFromRpcCode and should really only be used in tests.\n */\nfunction mapRpcCodeFromCode(code) {\n    if (code === undefined) {\n        return RpcCode.OK;\n    }\n    switch (code) {\n        case error_1.Code.OK:\n            return RpcCode.OK;\n        case error_1.Code.CANCELLED:\n            return RpcCode.CANCELLED;\n        case error_1.Code.UNKNOWN:\n            return RpcCode.UNKNOWN;\n        case error_1.Code.DEADLINE_EXCEEDED:\n            return RpcCode.DEADLINE_EXCEEDED;\n        case error_1.Code.RESOURCE_EXHAUSTED:\n            return RpcCode.RESOURCE_EXHAUSTED;\n        case error_1.Code.INTERNAL:\n            return RpcCode.INTERNAL;\n        case error_1.Code.UNAVAILABLE:\n            return RpcCode.UNAVAILABLE;\n        case error_1.Code.UNAUTHENTICATED:\n            return RpcCode.UNAUTHENTICATED;\n        case error_1.Code.INVALID_ARGUMENT:\n            return RpcCode.INVALID_ARGUMENT;\n        case error_1.Code.NOT_FOUND:\n            return RpcCode.NOT_FOUND;\n        case error_1.Code.ALREADY_EXISTS:\n            return RpcCode.ALREADY_EXISTS;\n        case error_1.Code.PERMISSION_DENIED:\n            return RpcCode.PERMISSION_DENIED;\n        case error_1.Code.FAILED_PRECONDITION:\n            return RpcCode.FAILED_PRECONDITION;\n        case error_1.Code.ABORTED:\n            return RpcCode.ABORTED;\n        case error_1.Code.OUT_OF_RANGE:\n            return RpcCode.OUT_OF_RANGE;\n        case error_1.Code.UNIMPLEMENTED:\n            return RpcCode.UNIMPLEMENTED;\n        case error_1.Code.DATA_LOSS:\n            return RpcCode.DATA_LOSS;\n        default:\n            return assert_1.fail('Unknown status code: ' + code);\n    }\n}\nexports.mapRpcCodeFromCode = mapRpcCodeFromCode;\n/**\n * Converts an HTTP Status Code to the equivalent error code.\n *\n * @param status An HTTP Status Code, like 200, 404, 503, etc.\n * @returns The equivalent Code. Unknown status codes are mapped to\n *     Code.UNKNOWN.\n */\nfunction mapCodeFromHttpStatus(status) {\n    // The canonical error codes for Google APIs [1] specify mapping onto HTTP\n    // status codes but the mapping is not bijective. In each case of ambiguity\n    // this function chooses a primary error.\n    //\n    // [1]\n    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto\n    switch (status) {\n        case 200:// OK\n            return error_1.Code.OK;\n        case 400:// Bad Request\n            return error_1.Code.INVALID_ARGUMENT;\n        // Other possibilities based on the forward mapping\n        // return Code.FAILED_PRECONDITION;\n        // return Code.OUT_OF_RANGE;\n        case 401:// Unauthorized\n            return error_1.Code.UNAUTHENTICATED;\n        case 403:// Forbidden\n            return error_1.Code.PERMISSION_DENIED;\n        case 404:// Not Found\n            return error_1.Code.NOT_FOUND;\n        case 409:// Conflict\n            return error_1.Code.ABORTED;\n        // Other possibilities:\n        // return Code.ALREADY_EXISTS;\n        case 416:// Range Not Satisfiable\n            return error_1.Code.OUT_OF_RANGE;\n        case 429:// Too Many Requests\n            return error_1.Code.RESOURCE_EXHAUSTED;\n        case 499:// Client Closed Request\n            return error_1.Code.CANCELLED;\n        case 500:// Internal Server Error\n            return error_1.Code.UNKNOWN;\n        // Other possibilities:\n        // return Code.INTERNAL;\n        // return Code.DATA_LOSS;\n        case 501:// Unimplemented\n            return error_1.Code.UNIMPLEMENTED;\n        case 503:// Service Unavailable\n            return error_1.Code.UNAVAILABLE;\n        case 504:// Gateway Timeout\n            return error_1.Code.DEADLINE_EXCEEDED;\n        default:\n            if (status >= 200 && status < 300)\n                return error_1.Code.OK;\n            if (status >= 400 && status < 500)\n                return error_1.Code.FAILED_PRECONDITION;\n            if (status >= 500 && status < 600)\n                return error_1.Code.INTERNAL;\n            return error_1.Code.UNKNOWN;\n    }\n}\nexports.mapCodeFromHttpStatus = mapCodeFromHttpStatus;\n\n//# sourceMappingURL=rpc_error.js.map\n"},"hash":"d085741662b28ab4e23005f1da4decf7"}