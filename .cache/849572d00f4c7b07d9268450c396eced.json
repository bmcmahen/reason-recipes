{"dependencies":[{"name":"./constants","loc":{"line":3,"column":24}},{"name":"./error","loc":{"line":4,"column":28}},{"name":"./failrequest","loc":{"line":5,"column":28}},{"name":"./location","loc":{"line":6,"column":25}},{"name":"./promise_external","loc":{"line":7,"column":26}},{"name":"./requestmap","loc":{"line":8,"column":27}},{"name":"./type","loc":{"line":9,"column":19}}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar constants = require(\"./constants\");\nvar errorsExports = require(\"./error\");\nvar failrequest_1 = require(\"./failrequest\");\nvar location_1 = require(\"./location\");\nvar promiseimpl = require(\"./promise_external\");\nvar requestmap_1 = require(\"./requestmap\");\nvar type = require(\"./type\");\n/**\n * @param app If null, getAuthToken always resolves with null.\n * @param service The storage service associated with this auth wrapper.\n *     Untyped to avoid circular type dependencies.\n * @struct\n */\nvar AuthWrapper = /** @class */ (function () {\n    function AuthWrapper(app, maker, requestMaker, service, pool) {\n        this.bucket_ = null;\n        this.deleted_ = false;\n        this.app_ = app;\n        if (this.app_ !== null) {\n            var options = this.app_.options;\n            if (type.isDef(options)) {\n                this.bucket_ = AuthWrapper.extractBucket_(options);\n            }\n        }\n        this.storageRefMaker_ = maker;\n        this.requestMaker_ = requestMaker;\n        this.pool_ = pool;\n        this.service_ = service;\n        this.maxOperationRetryTime_ = constants.defaultMaxOperationRetryTime;\n        this.maxUploadRetryTime_ = constants.defaultMaxUploadRetryTime;\n        this.requestMap_ = new requestmap_1.RequestMap();\n    }\n    AuthWrapper.extractBucket_ = function (config) {\n        var bucketString = config[constants.configOption] || null;\n        if (bucketString == null) {\n            return null;\n        }\n        var loc = location_1.Location.makeFromBucketSpec(bucketString);\n        return loc.bucket;\n    };\n    AuthWrapper.prototype.getAuthToken = function () {\n        // TODO(andysoto): remove ifDef checks after firebase-app implements stubs\n        // (b/28673818).\n        if (this.app_ !== null &&\n            type.isDef(this.app_.INTERNAL) &&\n            type.isDef(this.app_.INTERNAL.getToken)) {\n            return this.app_.INTERNAL.getToken().then(function (response) {\n                if (response !== null) {\n                    return response.accessToken;\n                }\n                else {\n                    return null;\n                }\n            }, function (_error) {\n                return null;\n            });\n        }\n        else {\n            return promiseimpl.resolve(null);\n        }\n    };\n    AuthWrapper.prototype.bucket = function () {\n        if (this.deleted_) {\n            throw errorsExports.appDeleted();\n        }\n        else {\n            return this.bucket_;\n        }\n    };\n    /**\n     * The service associated with this auth wrapper. Untyped to avoid circular\n     * type dependencies.\n     */\n    AuthWrapper.prototype.service = function () {\n        return this.service_;\n    };\n    /**\n     * Returns a new firebaseStorage.Reference object referencing this AuthWrapper\n     * at the given Location.\n     * @param loc The Location.\n     * @return Actually a firebaseStorage.Reference, typing not allowed\n     *     because of circular dependency problems.\n     */\n    AuthWrapper.prototype.makeStorageReference = function (loc) {\n        return this.storageRefMaker_(this, loc);\n    };\n    AuthWrapper.prototype.makeRequest = function (requestInfo, authToken) {\n        if (!this.deleted_) {\n            var request = this.requestMaker_(requestInfo, authToken, this.pool_);\n            this.requestMap_.addRequest(request);\n            return request;\n        }\n        else {\n            return new failrequest_1.FailRequest(errorsExports.appDeleted());\n        }\n    };\n    /**\n     * Stop running requests and prevent more from being created.\n     */\n    AuthWrapper.prototype.deleteApp = function () {\n        this.deleted_ = true;\n        this.app_ = null;\n        this.requestMap_.clear();\n    };\n    AuthWrapper.prototype.maxUploadRetryTime = function () {\n        return this.maxUploadRetryTime_;\n    };\n    AuthWrapper.prototype.setMaxUploadRetryTime = function (time) {\n        this.maxUploadRetryTime_ = time;\n    };\n    AuthWrapper.prototype.maxOperationRetryTime = function () {\n        return this.maxOperationRetryTime_;\n    };\n    AuthWrapper.prototype.setMaxOperationRetryTime = function (time) {\n        this.maxOperationRetryTime_ = time;\n    };\n    return AuthWrapper;\n}());\nexports.AuthWrapper = AuthWrapper;\n\n//# sourceMappingURL=authwrapper.js.map\n"},"hash":"eb60168162e78f9beeb8faed66fe0ce2"}