{"dependencies":[{"name":"../model/collections","loc":{"line":18,"column":28}},{"name":"../util/assert","loc":{"line":19,"column":23}},{"name":"./persistent_stream","loc":{"line":20,"column":34}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar collections_1 = require(\"../model/collections\");\nvar assert_1 = require(\"../util/assert\");\nvar persistent_stream_1 = require(\"./persistent_stream\");\n/**\n * Datastore is a wrapper around the external Google Cloud Datastore grpc API,\n * which provides an interface that is more convenient for the rest of the\n * client SDK architecture to consume.\n */\nvar Datastore = /** @class */ (function () {\n    function Datastore(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {\n        this.databaseInfo = databaseInfo;\n        this.queue = queue;\n        this.connection = connection;\n        this.credentials = credentials;\n        this.serializer = serializer;\n        this.initialBackoffDelay = initialBackoffDelay;\n    }\n    Datastore.prototype.newPersistentWriteStream = function () {\n        return new persistent_stream_1.PersistentWriteStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, this.initialBackoffDelay);\n    };\n    Datastore.prototype.newPersistentWatchStream = function () {\n        return new persistent_stream_1.PersistentListenStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, this.initialBackoffDelay);\n    };\n    Datastore.prototype.commit = function (mutations) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            writes: mutations.map(function (m) { return _this.serializer.toMutation(m); })\n        };\n        return this.invokeRPC('Commit', params).then(function (response) {\n            return _this.serializer.fromWriteResults(response.writeResults);\n        });\n    };\n    Datastore.prototype.lookup = function (keys) {\n        var _this = this;\n        var params = {\n            database: this.serializer.encodedDatabaseId,\n            documents: keys.map(function (k) { return _this.serializer.toName(k); })\n        };\n        return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {\n            var docs = collections_1.maybeDocumentMap();\n            response.forEach(function (proto) {\n                var doc = _this.serializer.fromMaybeDocument(proto);\n                docs = docs.insert(doc.key, doc);\n            });\n            var result = [];\n            keys.forEach(function (key) {\n                var doc = docs.get(key);\n                assert_1.assert(!!doc, 'Missing entity in write response for ' + key);\n                result.push(doc);\n            });\n            return result;\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC. */\n    Datastore.prototype.invokeRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeRPC(rpcName, request, token);\n        });\n    };\n    /** Gets an auth token and invokes the provided RPC with streamed results. */\n    Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {\n        var _this = this;\n        // TODO(mikelehen): Retry (with backoff) on token failures?\n        return this.credentials.getToken(/*forceRefresh=*/ false).then(function (token) {\n            return _this.connection.invokeStreamingRPC(rpcName, request, token);\n        });\n    };\n    return Datastore;\n}());\nexports.Datastore = Datastore;\n\n//# sourceMappingURL=datastore.js.map\n"},"hash":"7278e385794e177ce9214952974b936c"}