{"dependencies":[{"name":"../util/assert","loc":{"line":18,"column":23}},{"name":"../util/sorted_map","loc":{"line":19,"column":27}},{"name":"./collections","loc":{"line":20,"column":28}},{"name":"./document_key","loc":{"line":21,"column":29}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"../util/assert\");\nvar sorted_map_1 = require(\"../util/sorted_map\");\nvar collections_1 = require(\"./collections\");\nvar document_key_1 = require(\"./document_key\");\n/**\n * DocumentSet is an immutable (copy-on-write) collection that holds documents\n * in order specified by the provided comparator. We always add a document key\n * comparator on top of what is provided to guarantee document equality based on\n * the key.\n */\nvar DocumentSet = /** @class */ (function () {\n    /** The default ordering is by key if the comparator is omitted */\n    function DocumentSet(comp) {\n        // We are adding document key comparator to the end as it's the only\n        // guaranteed unique property of a document.\n        if (comp) {\n            this.comparator = function (d1, d2) {\n                return comp(d1, d2) || document_key_1.DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        else {\n            this.comparator = function (d1, d2) {\n                return document_key_1.DocumentKey.comparator(d1.key, d2.key);\n            };\n        }\n        this.keyedMap = collections_1.documentMap();\n        this.sortedSet = new sorted_map_1.SortedMap(this.comparator);\n    }\n    /**\n     * Returns an empty copy of the existing DocumentSet, using the same\n     * comparator.\n     */\n    DocumentSet.emptySet = function (oldSet) {\n        return new DocumentSet(oldSet.comparator);\n    };\n    DocumentSet.prototype.has = function (key) {\n        return this.keyedMap.get(key) != null;\n    };\n    DocumentSet.prototype.get = function (key) {\n        return this.keyedMap.get(key);\n    };\n    DocumentSet.prototype.first = function () {\n        return this.sortedSet.minKey();\n    };\n    DocumentSet.prototype.last = function () {\n        return this.sortedSet.maxKey();\n    };\n    DocumentSet.prototype.isEmpty = function () {\n        return this.sortedSet.isEmpty();\n    };\n    /**\n     * Returns previous document or null if it's a first doc.\n     *\n     * @param key A key that MUST be present in the DocumentSet.\n     */\n    DocumentSet.prototype.prevDoc = function (key) {\n        assert_1.assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);\n        var doc = this.keyedMap.get(key);\n        return this.sortedSet.getPredecessorKey(doc);\n    };\n    /**\n     * Returns the index of the provided key in the document set, or -1 if the\n     * document key is not present in the set;\n     */\n    DocumentSet.prototype.indexOf = function (key) {\n        var doc = this.keyedMap.get(key);\n        return doc ? this.sortedSet.indexOf(doc) : -1;\n    };\n    Object.defineProperty(DocumentSet.prototype, \"size\", {\n        get: function () {\n            return this.sortedSet.size;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** Iterates documents in order defined by \"comparator\" */\n    DocumentSet.prototype.forEach = function (cb) {\n        this.sortedSet.inorderTraversal(function (k, v) {\n            cb(k);\n            return false;\n        });\n    };\n    /** Inserts or updates a document with the same key */\n    DocumentSet.prototype.add = function (doc) {\n        // First remove the element if we have it.\n        var set = this.delete(doc.key);\n        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));\n    };\n    /** Deletes a document with a given key */\n    DocumentSet.prototype.delete = function (key) {\n        var doc = this.get(key);\n        if (!doc) {\n            return this;\n        }\n        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));\n    };\n    DocumentSet.prototype.equals = function (other) {\n        if (!(other instanceof DocumentSet))\n            return false;\n        if (this.size !== other.size)\n            return false;\n        var thisIt = this.sortedSet.getIterator();\n        var otherIt = other.sortedSet.getIterator();\n        while (thisIt.hasNext()) {\n            var thisDoc = thisIt.getNext().key;\n            var otherDoc = otherIt.getNext().key;\n            if (!thisDoc.equals(otherDoc))\n                return false;\n        }\n        return true;\n    };\n    DocumentSet.prototype.toString = function () {\n        var docStrings = [];\n        this.forEach(function (doc) {\n            docStrings.push(doc.toString());\n        });\n        if (docStrings.length === 0) {\n            return 'DocumentSet ()';\n        }\n        else {\n            return 'DocumentSet (\\n  ' + docStrings.join('  \\n') + '\\n)';\n        }\n    };\n    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {\n        var newSet = new DocumentSet();\n        newSet.comparator = this.comparator;\n        newSet.keyedMap = keyedMap;\n        newSet.sortedSet = sortedSet;\n        return newSet;\n    };\n    return DocumentSet;\n}());\nexports.DocumentSet = DocumentSet;\n\n//# sourceMappingURL=document_set.js.map\n"},"hash":"7a3f04068bd425b4f1c607f923822d6e"}