{"dependencies":[{"name":"./bytes.js","loc":{"line":3,"column":38}},{"name":"./curry.js","loc":{"line":4,"column":38}},{"name":"./string.js","loc":{"line":5,"column":38}},{"name":"./pervasives.js","loc":{"line":6,"column":38}},{"name":"./caml_string.js","loc":{"line":7,"column":38}},{"name":"./caml_builtin_exceptions.js","loc":{"line":8,"column":38}}],"generated":{"js":"'use strict';\n\nvar Bytes                   = require(\"./bytes.js\");\nvar Curry                   = require(\"./curry.js\");\nvar $$String                = require(\"./string.js\");\nvar Pervasives              = require(\"./pervasives.js\");\nvar Caml_string             = require(\"./caml_string.js\");\nvar Caml_builtin_exceptions = require(\"./caml_builtin_exceptions.js\");\n\nfunction create(n) {\n  var n$1 = n < 1 ? 1 : n;\n  var s = Caml_string.caml_create_string(n$1);\n  return /* record */[\n          /* buffer */s,\n          /* position */0,\n          /* length */n$1,\n          /* initial_buffer */s\n        ];\n}\n\nfunction contents(b) {\n  return Bytes.sub_string(b[/* buffer */0], 0, b[/* position */1]);\n}\n\nfunction to_bytes(b) {\n  return Bytes.sub(b[/* buffer */0], 0, b[/* position */1]);\n}\n\nfunction sub(b, ofs, len) {\n  if (ofs < 0 || len < 0 || ofs > (b[/* position */1] - len | 0)) {\n    throw [\n          Caml_builtin_exceptions.invalid_argument,\n          \"Buffer.sub\"\n        ];\n  } else {\n    return Bytes.sub_string(b[/* buffer */0], ofs, len);\n  }\n}\n\nfunction blit(src, srcoff, dst, dstoff, len) {\n  if (len < 0 || srcoff < 0 || srcoff > (src[/* position */1] - len | 0) || dstoff < 0 || dstoff > (dst.length - len | 0)) {\n    throw [\n          Caml_builtin_exceptions.invalid_argument,\n          \"Buffer.blit\"\n        ];\n  } else {\n    return Bytes.blit(src[/* buffer */0], srcoff, dst, dstoff, len);\n  }\n}\n\nfunction nth(b, ofs) {\n  if (ofs < 0 || ofs >= b[/* position */1]) {\n    throw [\n          Caml_builtin_exceptions.invalid_argument,\n          \"Buffer.nth\"\n        ];\n  } else {\n    return b[/* buffer */0][ofs];\n  }\n}\n\nfunction length(b) {\n  return b[/* position */1];\n}\n\nfunction clear(b) {\n  b[/* position */1] = 0;\n  return /* () */0;\n}\n\nfunction reset(b) {\n  b[/* position */1] = 0;\n  b[/* buffer */0] = b[/* initial_buffer */3];\n  b[/* length */2] = b[/* buffer */0].length;\n  return /* () */0;\n}\n\nfunction resize(b, more) {\n  var len = b[/* length */2];\n  var new_len = len;\n  while((b[/* position */1] + more | 0) > new_len) {\n    new_len = (new_len << 1);\n  };\n  var new_buffer = Caml_string.caml_create_string(new_len);\n  Bytes.blit(b[/* buffer */0], 0, new_buffer, 0, b[/* position */1]);\n  b[/* buffer */0] = new_buffer;\n  b[/* length */2] = new_len;\n  return /* () */0;\n}\n\nfunction add_char(b, c) {\n  var pos = b[/* position */1];\n  if (pos >= b[/* length */2]) {\n    resize(b, 1);\n  }\n  b[/* buffer */0][pos] = c;\n  b[/* position */1] = pos + 1 | 0;\n  return /* () */0;\n}\n\nfunction add_substring(b, s, offset, len) {\n  if (offset < 0 || len < 0 || (offset + len | 0) > s.length) {\n    throw [\n          Caml_builtin_exceptions.invalid_argument,\n          \"Buffer.add_substring/add_subbytes\"\n        ];\n  }\n  var new_position = b[/* position */1] + len | 0;\n  if (new_position > b[/* length */2]) {\n    resize(b, len);\n  }\n  Bytes.blit_string(s, offset, b[/* buffer */0], b[/* position */1], len);\n  b[/* position */1] = new_position;\n  return /* () */0;\n}\n\nfunction add_subbytes(b, s, offset, len) {\n  return add_substring(b, Caml_string.bytes_to_string(s), offset, len);\n}\n\nfunction add_string(b, s) {\n  var len = s.length;\n  var new_position = b[/* position */1] + len | 0;\n  if (new_position > b[/* length */2]) {\n    resize(b, len);\n  }\n  Bytes.blit_string(s, 0, b[/* buffer */0], b[/* position */1], len);\n  b[/* position */1] = new_position;\n  return /* () */0;\n}\n\nfunction add_bytes(b, s) {\n  return add_string(b, Caml_string.bytes_to_string(s));\n}\n\nfunction add_buffer(b, bs) {\n  return add_subbytes(b, bs[/* buffer */0], 0, bs[/* position */1]);\n}\n\nfunction add_channel(b, ic, len) {\n  if (len < 0) {\n    throw [\n          Caml_builtin_exceptions.invalid_argument,\n          \"Buffer.add_channel\"\n        ];\n  }\n  if ((b[/* position */1] + len | 0) > b[/* length */2]) {\n    resize(b, len);\n  }\n  Pervasives.really_input(ic, b[/* buffer */0], b[/* position */1], len);\n  b[/* position */1] = b[/* position */1] + len | 0;\n  return /* () */0;\n}\n\nfunction output_buffer(oc, b) {\n  return Pervasives.output(oc, b[/* buffer */0], 0, b[/* position */1]);\n}\n\nfunction closing(param) {\n  if (param !== 40) {\n    if (param !== 123) {\n      throw [\n            Caml_builtin_exceptions.assert_failure,\n            [\n              \"buffer.ml\",\n              126,\n              9\n            ]\n          ];\n    } else {\n      return /* \"}\" */125;\n    }\n  } else {\n    return /* \")\" */41;\n  }\n}\n\nfunction advance_to_closing(opening, closing, k, s, start) {\n  var _k = k;\n  var _i = start;\n  var lim = s.length;\n  while(true) {\n    var i = _i;\n    var k$1 = _k;\n    if (i >= lim) {\n      throw Caml_builtin_exceptions.not_found;\n    } else if (Caml_string.get(s, i) === opening) {\n      _i = i + 1 | 0;\n      _k = k$1 + 1 | 0;\n      continue ;\n      \n    } else if (Caml_string.get(s, i) === closing) {\n      if (k$1) {\n        _i = i + 1 | 0;\n        _k = k$1 - 1 | 0;\n        continue ;\n        \n      } else {\n        return i;\n      }\n    } else {\n      _i = i + 1 | 0;\n      continue ;\n      \n    }\n  };\n}\n\nfunction advance_to_non_alpha(s, start) {\n  var _i = start;\n  var lim = s.length;\n  while(true) {\n    var i = _i;\n    if (i >= lim) {\n      return lim;\n    } else {\n      var match = Caml_string.get(s, i);\n      var exit = 0;\n      if (match >= 91) {\n        if (match >= 97) {\n          if (match >= 123) {\n            return i;\n          } else {\n            exit = 1;\n          }\n        } else if (match !== 95) {\n          return i;\n        } else {\n          exit = 1;\n        }\n      } else if (match >= 58) {\n        if (match >= 65) {\n          exit = 1;\n        } else {\n          return i;\n        }\n      } else if (match >= 48) {\n        exit = 1;\n      } else {\n        return i;\n      }\n      if (exit === 1) {\n        _i = i + 1 | 0;\n        continue ;\n        \n      }\n      \n    }\n  };\n}\n\nfunction find_ident(s, start, lim) {\n  if (start >= lim) {\n    throw Caml_builtin_exceptions.not_found;\n  } else {\n    var c = Caml_string.get(s, start);\n    var exit = 0;\n    if (c !== 40) {\n      if (c !== 123) {\n        var stop = advance_to_non_alpha(s, start + 1 | 0);\n        return /* tuple */[\n                $$String.sub(s, start, stop - start | 0),\n                stop\n              ];\n      } else {\n        exit = 1;\n      }\n    } else {\n      exit = 1;\n    }\n    if (exit === 1) {\n      var new_start = start + 1 | 0;\n      var stop$1 = advance_to_closing(c, closing(c), 0, s, new_start);\n      return /* tuple */[\n              $$String.sub(s, new_start, (stop$1 - start | 0) - 1 | 0),\n              stop$1 + 1 | 0\n            ];\n    }\n    \n  }\n}\n\nfunction add_substitute(b, f, s) {\n  var lim = s.length;\n  var _previous = /* \" \" */32;\n  var _i = 0;\n  while(true) {\n    var i = _i;\n    var previous = _previous;\n    if (i < lim) {\n      var current = Caml_string.get(s, i);\n      if (current !== 36) {\n        if (previous === /* \"\\\\\" */92) {\n          add_char(b, /* \"\\\\\" */92);\n          add_char(b, current);\n          _i = i + 1 | 0;\n          _previous = /* \" \" */32;\n          continue ;\n          \n        } else if (current !== 92) {\n          add_char(b, current);\n          _i = i + 1 | 0;\n          _previous = current;\n          continue ;\n          \n        } else {\n          _i = i + 1 | 0;\n          _previous = current;\n          continue ;\n          \n        }\n      } else if (previous === /* \"\\\\\" */92) {\n        add_char(b, current);\n        _i = i + 1 | 0;\n        _previous = /* \" \" */32;\n        continue ;\n        \n      } else {\n        var j = i + 1 | 0;\n        var match = find_ident(s, j, lim);\n        add_string(b, Curry._1(f, match[0]));\n        _i = match[1];\n        _previous = /* \" \" */32;\n        continue ;\n        \n      }\n    } else if (previous === /* \"\\\\\" */92) {\n      return add_char(b, previous);\n    } else {\n      return 0;\n    }\n  };\n}\n\nexports.create         = create;\nexports.contents       = contents;\nexports.to_bytes       = to_bytes;\nexports.sub            = sub;\nexports.blit           = blit;\nexports.nth            = nth;\nexports.length         = length;\nexports.clear          = clear;\nexports.reset          = reset;\nexports.add_char       = add_char;\nexports.add_string     = add_string;\nexports.add_bytes      = add_bytes;\nexports.add_substring  = add_substring;\nexports.add_subbytes   = add_subbytes;\nexports.add_substitute = add_substitute;\nexports.add_buffer     = add_buffer;\nexports.add_channel    = add_channel;\nexports.output_buffer  = output_buffer;\n/* No side effect */\n"},"hash":"8cb4cafe9a67ab633fa0b6991ca3a32b"}