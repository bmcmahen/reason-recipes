{"dependencies":[{"name":"../core/snapshot_version","loc":{"line":18,"column":33}},{"name":"../core/timestamp","loc":{"line":19,"column":26}},{"name":"../model/document","loc":{"line":20,"column":25}},{"name":"../model/document_key","loc":{"line":21,"column":29}},{"name":"../model/mutation_batch","loc":{"line":22,"column":31}},{"name":"../util/assert","loc":{"line":23,"column":23}},{"name":"./indexeddb_schema","loc":{"line":24,"column":33}},{"name":"./query_data","loc":{"line":25,"column":27}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar snapshot_version_1 = require(\"../core/snapshot_version\");\nvar timestamp_1 = require(\"../core/timestamp\");\nvar document_1 = require(\"../model/document\");\nvar document_key_1 = require(\"../model/document_key\");\nvar mutation_batch_1 = require(\"../model/mutation_batch\");\nvar assert_1 = require(\"../util/assert\");\nvar indexeddb_schema_1 = require(\"./indexeddb_schema\");\nvar query_data_1 = require(\"./query_data\");\n/** Serializer for values stored in the LocalStore. */\nvar LocalSerializer = /** @class */ (function () {\n    function LocalSerializer(remoteSerializer) {\n        this.remoteSerializer = remoteSerializer;\n    }\n    /** Decodes a remote document from storage locally to a Document. */\n    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {\n        if (remoteDoc.document) {\n            return this.remoteSerializer.fromDocument(remoteDoc.document);\n        }\n        else if (remoteDoc.noDocument) {\n            var key = document_key_1.DocumentKey.fromSegments(remoteDoc.noDocument.path);\n            var readTime = remoteDoc.noDocument.readTime;\n            var timestamp = new timestamp_1.Timestamp(readTime.seconds, readTime.nanos);\n            return new document_1.NoDocument(key, snapshot_version_1.SnapshotVersion.fromTimestamp(timestamp));\n        }\n        else {\n            return assert_1.fail('Unexpected DbRemoteDocument');\n        }\n    };\n    /** Encodes a document for storage locally. */\n    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {\n        if (maybeDoc instanceof document_1.Document) {\n            var doc = this.remoteSerializer.toDocument(maybeDoc);\n            return new indexeddb_schema_1.DbRemoteDocument(null, doc);\n        }\n        else {\n            var path = maybeDoc.key.path.toArray();\n            var timestamp = maybeDoc.version.toTimestamp();\n            var readTime = new indexeddb_schema_1.DbTimestamp(timestamp.seconds, timestamp.nanos);\n            return new indexeddb_schema_1.DbRemoteDocument(new indexeddb_schema_1.DbNoDocument(path, readTime), null);\n        }\n    };\n    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */\n    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {\n        var _this = this;\n        var serializedMutations = batch.mutations.map(function (m) {\n            return _this.remoteSerializer.toMutation(m);\n        });\n        return new indexeddb_schema_1.DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);\n    };\n    /** Decodes a DbMutationBatch into a MutationBatch */\n    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {\n        var _this = this;\n        var mutations = dbBatch.mutations.map(function (m) {\n            return _this.remoteSerializer.fromMutation(m);\n        });\n        var timestamp = timestamp_1.Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);\n        return new mutation_batch_1.MutationBatch(dbBatch.batchId, timestamp, mutations);\n    };\n    /** Decodes a DbTarget into QueryData */\n    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {\n        var readTime = new timestamp_1.Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);\n        var version = snapshot_version_1.SnapshotVersion.fromTimestamp(readTime);\n        var query;\n        if (isDocumentQuery(dbTarget.query)) {\n            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);\n        }\n        else {\n            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);\n        }\n        return new query_data_1.QueryData(query, dbTarget.targetId, query_data_1.QueryPurpose.Listen, version, dbTarget.resumeToken);\n    };\n    /** Encodes QueryData into a DbTarget for storage locally. */\n    LocalSerializer.prototype.toDbTarget = function (queryData) {\n        assert_1.assert(query_data_1.QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' +\n            query_data_1.QueryPurpose.Listen +\n            ' may be stored, got ' +\n            queryData.purpose);\n        var timestamp = queryData.snapshotVersion.toTimestamp();\n        var dbTimestamp = new indexeddb_schema_1.DbTimestamp(timestamp.seconds, timestamp.nanos);\n        var queryProto;\n        if (queryData.query.isDocumentQuery()) {\n            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);\n        }\n        else {\n            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);\n        }\n        assert_1.assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');\n        var resumeToken = queryData.resumeToken;\n        // lastListenSequenceNumber is always 0 until we do real GC.\n        return new indexeddb_schema_1.DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);\n    };\n    return LocalSerializer;\n}());\nexports.LocalSerializer = LocalSerializer;\n/**\n * A helper function for figuring out what kind of query has been stored.\n */\nfunction isDocumentQuery(dbQuery) {\n    return dbQuery.documents !== undefined;\n}\n\n//# sourceMappingURL=local_serializer.js.map\n"},"hash":"dc08ee059747999b91fcc87e5949cdaf"}