{"dependencies":[{"name":"./assert","loc":{"line":18,"column":23}}],"generated":{"js":"\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar assert_1 = require(\"./assert\");\n// tslint:disable-next-line:class-as-namespace\nvar AutoId = /** @class */ (function () {\n    function AutoId() {\n    }\n    AutoId.newId = function () {\n        // Alphanumeric characters\n        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n        var autoId = '';\n        for (var i = 0; i < 20; i++) {\n            autoId += chars.charAt(Math.floor(Math.random() * chars.length));\n        }\n        assert_1.assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);\n        return autoId;\n    };\n    return AutoId;\n}());\nexports.AutoId = AutoId;\nfunction primitiveComparator(left, right) {\n    if (left < right)\n        return -1;\n    if (left > right)\n        return 1;\n    return 0;\n}\nexports.primitiveComparator = primitiveComparator;\n/** Helper to compare nullable (or undefined-able) objects using equals(). */\nfunction equals(left, right) {\n    if (left !== null && left !== undefined) {\n        return !!(right && left.equals(right));\n    }\n    else {\n        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't\n        // smart enough.\n        return left === right;\n    }\n}\nexports.equals = equals;\n/** Helper to compare arrays using equals(). */\nfunction arrayEquals(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (var i = 0; i < left.length; i++) {\n        if (!left[i].equals(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.arrayEquals = arrayEquals;\n/**\n * Returns the largest lexicographically smaller string of equal or smaller\n * length. Returns an empty string if there is no such predecessor (if the input\n * is empty).\n *\n * Strings returned from this method can be invalid UTF-16 but this is sufficent\n * in use for indexeddb because that depends on lexicographical ordering but\n * shouldn't be used elsewhere.\n */\nfunction immediatePredecessor(s) {\n    // We can decrement the last character in the string and be done\n    // unless that character is 0 (0x0000), in which case we have to erase the\n    // last character.\n    var lastIndex = s.length - 1;\n    if (s.length === 0) {\n        // Special case the empty string.\n        return '';\n    }\n    else if (s.charAt(lastIndex) === '\\0') {\n        return s.substring(0, lastIndex);\n    }\n    else {\n        return (s.substring(0, lastIndex) +\n            String.fromCharCode(s.charCodeAt(lastIndex) - 1));\n    }\n}\nexports.immediatePredecessor = immediatePredecessor;\n/**\n * Returns the immediate lexicographically-following string. This is useful to\n * construct an inclusive range for indexeddb iterators.\n */\nfunction immediateSuccessor(s) {\n    // Return the input string, with an additional NUL byte appended.\n    return s + '\\0';\n}\nexports.immediateSuccessor = immediateSuccessor;\n\n//# sourceMappingURL=misc.js.map\n"},"hash":"80f9651a936e34e0a23145c6d90ab98f"}