{"dependencies":[{"name":"./array.js","loc":{"line":3,"column":38}},{"name":"./block.js","loc":{"line":4,"column":38}},{"name":"./curry.js","loc":{"line":5,"column":38}},{"name":"./random.js","loc":{"line":6,"column":38}},{"name":"./caml_obj.js","loc":{"line":7,"column":38}},{"name":"./caml_hash.js","loc":{"line":8,"column":38}},{"name":"./caml_array.js","loc":{"line":9,"column":38}},{"name":"./pervasives.js","loc":{"line":10,"column":38}},{"name":"./camlinternalLazy.js","loc":{"line":11,"column":38}},{"name":"./caml_missing_polyfill.js","loc":{"line":12,"column":38}},{"name":"./caml_builtin_exceptions.js","loc":{"line":13,"column":38}}],"generated":{"js":"'use strict';\n\nvar $$Array                 = require(\"./array.js\");\nvar Block                   = require(\"./block.js\");\nvar Curry                   = require(\"./curry.js\");\nvar Random                  = require(\"./random.js\");\nvar Caml_obj                = require(\"./caml_obj.js\");\nvar Caml_hash               = require(\"./caml_hash.js\");\nvar Caml_array              = require(\"./caml_array.js\");\nvar Pervasives              = require(\"./pervasives.js\");\nvar CamlinternalLazy        = require(\"./camlinternalLazy.js\");\nvar Caml_missing_polyfill   = require(\"./caml_missing_polyfill.js\");\nvar Caml_builtin_exceptions = require(\"./caml_builtin_exceptions.js\");\n\nfunction hash(x) {\n  return Caml_hash.caml_hash(10, 100, 0, x);\n}\n\nfunction hash_param(n1, n2, x) {\n  return Caml_hash.caml_hash(n1, n2, 0, x);\n}\n\nfunction seeded_hash(seed, x) {\n  return Caml_hash.caml_hash(10, 100, seed, x);\n}\n\nvar randomized = [/* false */0];\n\nfunction randomize() {\n  randomized[0] = /* true */1;\n  return /* () */0;\n}\n\nvar prng = Block.__(246, [(function () {\n        return Random.State[/* make_self_init */1](/* () */0);\n      })]);\n\nfunction power_2_above(_x, n) {\n  while(true) {\n    var x = _x;\n    if (x >= n) {\n      return x;\n    } else if ((x << 1) < x) {\n      return x;\n    } else {\n      _x = (x << 1);\n      continue ;\n      \n    }\n  };\n}\n\nfunction create($staropt$star, initial_size) {\n  var random = $staropt$star ? $staropt$star[0] : randomized[0];\n  var s = power_2_above(16, initial_size);\n  var seed;\n  if (random) {\n    var tag = prng.tag | 0;\n    seed = Random.State[/* bits */3](tag === 250 ? prng[0] : (\n            tag === 246 ? CamlinternalLazy.force_lazy_block(prng) : prng\n          ));\n  } else {\n    seed = 0;\n  }\n  return /* record */[\n          /* size */0,\n          /* data */Caml_array.caml_make_vect(s, /* Empty */0),\n          /* seed */seed,\n          /* initial_size */s\n        ];\n}\n\nfunction clear(h) {\n  h[/* size */0] = 0;\n  var len = h[/* data */1].length;\n  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){\n    Caml_array.caml_array_set(h[/* data */1], i, /* Empty */0);\n  }\n  return /* () */0;\n}\n\nfunction reset(h) {\n  var len = h[/* data */1].length;\n  if (h.length < 4 || len === h[/* initial_size */3]) {\n    return clear(h);\n  } else {\n    h[/* size */0] = 0;\n    h[/* data */1] = Caml_array.caml_make_vect(h[/* initial_size */3], /* Empty */0);\n    return /* () */0;\n  }\n}\n\nfunction copy(h) {\n  return /* record */[\n          /* size */h[/* size */0],\n          /* data */$$Array.copy(h[/* data */1]),\n          /* seed */h[/* seed */2],\n          /* initial_size */h[/* initial_size */3]\n        ];\n}\n\nfunction length(h) {\n  return h[/* size */0];\n}\n\nfunction resize(indexfun, h) {\n  var odata = h[/* data */1];\n  var osize = odata.length;\n  var nsize = (osize << 1);\n  if (nsize >= osize) {\n    var ndata = Caml_array.caml_make_vect(nsize, /* Empty */0);\n    h[/* data */1] = ndata;\n    var insert_bucket = function (param) {\n      if (param) {\n        var key = param[0];\n        insert_bucket(param[2]);\n        var nidx = Curry._2(indexfun, h, key);\n        return Caml_array.caml_array_set(ndata, nidx, /* Cons */[\n                    key,\n                    param[1],\n                    Caml_array.caml_array_get(ndata, nidx)\n                  ]);\n      } else {\n        return /* () */0;\n      }\n    };\n    for(var i = 0 ,i_finish = osize - 1 | 0; i <= i_finish; ++i){\n      insert_bucket(Caml_array.caml_array_get(odata, i));\n    }\n    return /* () */0;\n  } else {\n    return 0;\n  }\n}\n\nfunction key_index(h, key) {\n  if (h.length >= 3) {\n    return Caml_hash.caml_hash(10, 100, h[/* seed */2], key) & (h[/* data */1].length - 1 | 0);\n  } else {\n    return Caml_missing_polyfill.not_implemented(\"caml_hash_univ_param not implemented by bucklescript yet\\n\") % h[/* data */1].length;\n  }\n}\n\nfunction add(h, key, info) {\n  var i = key_index(h, key);\n  var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);\n  var bucket = /* Cons */[\n    key,\n    info,\n    bucket_002\n  ];\n  Caml_array.caml_array_set(h[/* data */1], i, bucket);\n  h[/* size */0] = h[/* size */0] + 1 | 0;\n  if (h[/* size */0] > (h[/* data */1].length << 1)) {\n    return resize(key_index, h);\n  } else {\n    return 0;\n  }\n}\n\nfunction remove(h, key) {\n  var remove_bucket = function (param) {\n    if (param) {\n      var next = param[2];\n      var k = param[0];\n      if (Caml_obj.caml_compare(k, key)) {\n        return /* Cons */[\n                k,\n                param[1],\n                remove_bucket(next)\n              ];\n      } else {\n        h[/* size */0] = h[/* size */0] - 1 | 0;\n        return next;\n      }\n    } else {\n      return /* Empty */0;\n    }\n  };\n  var i = key_index(h, key);\n  return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));\n}\n\nfunction find(h, key) {\n  var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n  if (match) {\n    if (Caml_obj.caml_compare(key, match[0])) {\n      var rest1 = match[2];\n      if (rest1) {\n        if (Caml_obj.caml_compare(key, rest1[0])) {\n          var rest2 = rest1[2];\n          if (rest2) {\n            if (Caml_obj.caml_compare(key, rest2[0])) {\n              var key$1 = key;\n              var _param = rest2[2];\n              while(true) {\n                var param = _param;\n                if (param) {\n                  if (Caml_obj.caml_compare(key$1, param[0])) {\n                    _param = param[2];\n                    continue ;\n                    \n                  } else {\n                    return param[1];\n                  }\n                } else {\n                  throw Caml_builtin_exceptions.not_found;\n                }\n              };\n            } else {\n              return rest2[1];\n            }\n          } else {\n            throw Caml_builtin_exceptions.not_found;\n          }\n        } else {\n          return rest1[1];\n        }\n      } else {\n        throw Caml_builtin_exceptions.not_found;\n      }\n    } else {\n      return match[1];\n    }\n  } else {\n    throw Caml_builtin_exceptions.not_found;\n  }\n}\n\nfunction find_all(h, key) {\n  var find_in_bucket = function (_param) {\n    while(true) {\n      var param = _param;\n      if (param) {\n        var rest = param[2];\n        if (Caml_obj.caml_compare(param[0], key)) {\n          _param = rest;\n          continue ;\n          \n        } else {\n          return /* :: */[\n                  param[1],\n                  find_in_bucket(rest)\n                ];\n        }\n      } else {\n        return /* [] */0;\n      }\n    };\n  };\n  return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));\n}\n\nfunction replace(h, key, info) {\n  var replace_bucket = function (param) {\n    if (param) {\n      var next = param[2];\n      var k = param[0];\n      if (Caml_obj.caml_compare(k, key)) {\n        return /* Cons */[\n                k,\n                param[1],\n                replace_bucket(next)\n              ];\n      } else {\n        return /* Cons */[\n                key,\n                info,\n                next\n              ];\n      }\n    } else {\n      throw Caml_builtin_exceptions.not_found;\n    }\n  };\n  var i = key_index(h, key);\n  var l = Caml_array.caml_array_get(h[/* data */1], i);\n  try {\n    return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));\n  }\n  catch (exn){\n    if (exn === Caml_builtin_exceptions.not_found) {\n      Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[\n            key,\n            info,\n            l\n          ]);\n      h[/* size */0] = h[/* size */0] + 1 | 0;\n      if (h[/* size */0] > (h[/* data */1].length << 1)) {\n        return resize(key_index, h);\n      } else {\n        return 0;\n      }\n    } else {\n      throw exn;\n    }\n  }\n}\n\nfunction mem(h, key) {\n  var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n  while(true) {\n    var param = _param;\n    if (param) {\n      if (Caml_obj.caml_compare(param[0], key)) {\n        _param = param[2];\n        continue ;\n        \n      } else {\n        return /* true */1;\n      }\n    } else {\n      return /* false */0;\n    }\n  };\n}\n\nfunction iter(f, h) {\n  var do_bucket = function (_param) {\n    while(true) {\n      var param = _param;\n      if (param) {\n        Curry._2(f, param[0], param[1]);\n        _param = param[2];\n        continue ;\n        \n      } else {\n        return /* () */0;\n      }\n    };\n  };\n  var d = h[/* data */1];\n  for(var i = 0 ,i_finish = d.length - 1 | 0; i <= i_finish; ++i){\n    do_bucket(Caml_array.caml_array_get(d, i));\n  }\n  return /* () */0;\n}\n\nfunction fold(f, h, init) {\n  var do_bucket = function (_b, _accu) {\n    while(true) {\n      var accu = _accu;\n      var b = _b;\n      if (b) {\n        _accu = Curry._3(f, b[0], b[1], accu);\n        _b = b[2];\n        continue ;\n        \n      } else {\n        return accu;\n      }\n    };\n  };\n  var d = h[/* data */1];\n  var accu = init;\n  for(var i = 0 ,i_finish = d.length - 1 | 0; i <= i_finish; ++i){\n    accu = do_bucket(Caml_array.caml_array_get(d, i), accu);\n  }\n  return accu;\n}\n\nfunction bucket_length(_accu, _param) {\n  while(true) {\n    var param = _param;\n    var accu = _accu;\n    if (param) {\n      _param = param[2];\n      _accu = accu + 1 | 0;\n      continue ;\n      \n    } else {\n      return accu;\n    }\n  };\n}\n\nfunction stats(h) {\n  var mbl = $$Array.fold_left((function (m, b) {\n          return Pervasives.max(m, bucket_length(0, b));\n        }), 0, h[/* data */1]);\n  var histo = Caml_array.caml_make_vect(mbl + 1 | 0, 0);\n  $$Array.iter((function (b) {\n          var l = bucket_length(0, b);\n          return Caml_array.caml_array_set(histo, l, Caml_array.caml_array_get(histo, l) + 1 | 0);\n        }), h[/* data */1]);\n  return /* record */[\n          /* num_bindings */h[/* size */0],\n          /* num_buckets */h[/* data */1].length,\n          /* max_bucket_length */mbl,\n          /* bucket_histogram */histo\n        ];\n}\n\nfunction MakeSeeded(H) {\n  var key_index = function (h, key) {\n    return Curry._2(H[/* hash */1], h[/* seed */2], key) & (h[/* data */1].length - 1 | 0);\n  };\n  var add = function (h, key, info) {\n    var i = key_index(h, key);\n    var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);\n    var bucket = /* Cons */[\n      key,\n      info,\n      bucket_002\n    ];\n    Caml_array.caml_array_set(h[/* data */1], i, bucket);\n    h[/* size */0] = h[/* size */0] + 1 | 0;\n    if (h[/* size */0] > (h[/* data */1].length << 1)) {\n      return resize(key_index, h);\n    } else {\n      return 0;\n    }\n  };\n  var remove = function (h, key) {\n    var remove_bucket = function (param) {\n      if (param) {\n        var next = param[2];\n        var k = param[0];\n        if (Curry._2(H[/* equal */0], k, key)) {\n          h[/* size */0] = h[/* size */0] - 1 | 0;\n          return next;\n        } else {\n          return /* Cons */[\n                  k,\n                  param[1],\n                  remove_bucket(next)\n                ];\n        }\n      } else {\n        return /* Empty */0;\n      }\n    };\n    var i = key_index(h, key);\n    return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));\n  };\n  var find = function (h, key) {\n    var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n    if (match) {\n      var rest1 = match[2];\n      if (Curry._2(H[/* equal */0], key, match[0])) {\n        return match[1];\n      } else if (rest1) {\n        var rest2 = rest1[2];\n        if (Curry._2(H[/* equal */0], key, rest1[0])) {\n          return rest1[1];\n        } else if (rest2) {\n          if (Curry._2(H[/* equal */0], key, rest2[0])) {\n            return rest2[1];\n          } else {\n            var key$1 = key;\n            var _param = rest2[2];\n            while(true) {\n              var param = _param;\n              if (param) {\n                if (Curry._2(H[/* equal */0], key$1, param[0])) {\n                  return param[1];\n                } else {\n                  _param = param[2];\n                  continue ;\n                  \n                }\n              } else {\n                throw Caml_builtin_exceptions.not_found;\n              }\n            };\n          }\n        } else {\n          throw Caml_builtin_exceptions.not_found;\n        }\n      } else {\n        throw Caml_builtin_exceptions.not_found;\n      }\n    } else {\n      throw Caml_builtin_exceptions.not_found;\n    }\n  };\n  var find_all = function (h, key) {\n    var find_in_bucket = function (_param) {\n      while(true) {\n        var param = _param;\n        if (param) {\n          var rest = param[2];\n          if (Curry._2(H[/* equal */0], param[0], key)) {\n            return /* :: */[\n                    param[1],\n                    find_in_bucket(rest)\n                  ];\n          } else {\n            _param = rest;\n            continue ;\n            \n          }\n        } else {\n          return /* [] */0;\n        }\n      };\n    };\n    return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));\n  };\n  var replace = function (h, key, info) {\n    var replace_bucket = function (param) {\n      if (param) {\n        var next = param[2];\n        var k = param[0];\n        if (Curry._2(H[/* equal */0], k, key)) {\n          return /* Cons */[\n                  key,\n                  info,\n                  next\n                ];\n        } else {\n          return /* Cons */[\n                  k,\n                  param[1],\n                  replace_bucket(next)\n                ];\n        }\n      } else {\n        throw Caml_builtin_exceptions.not_found;\n      }\n    };\n    var i = key_index(h, key);\n    var l = Caml_array.caml_array_get(h[/* data */1], i);\n    try {\n      return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));\n    }\n    catch (exn){\n      if (exn === Caml_builtin_exceptions.not_found) {\n        Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[\n              key,\n              info,\n              l\n            ]);\n        h[/* size */0] = h[/* size */0] + 1 | 0;\n        if (h[/* size */0] > (h[/* data */1].length << 1)) {\n          return resize(key_index, h);\n        } else {\n          return 0;\n        }\n      } else {\n        throw exn;\n      }\n    }\n  };\n  var mem = function (h, key) {\n    var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n    while(true) {\n      var param = _param;\n      if (param) {\n        if (Curry._2(H[/* equal */0], param[0], key)) {\n          return /* true */1;\n        } else {\n          _param = param[2];\n          continue ;\n          \n        }\n      } else {\n        return /* false */0;\n      }\n    };\n  };\n  return /* module */[\n          /* create */create,\n          /* clear */clear,\n          /* reset */reset,\n          /* copy */copy,\n          /* add */add,\n          /* remove */remove,\n          /* find */find,\n          /* find_all */find_all,\n          /* replace */replace,\n          /* mem */mem,\n          /* iter */iter,\n          /* fold */fold,\n          /* length */length,\n          /* stats */stats\n        ];\n}\n\nfunction Make(H) {\n  var equal = H[/* equal */0];\n  var key_index = function (h, key) {\n    return Curry._1(H[/* hash */1], key) & (h[/* data */1].length - 1 | 0);\n  };\n  var add = function (h, key, info) {\n    var i = key_index(h, key);\n    var bucket_002 = Caml_array.caml_array_get(h[/* data */1], i);\n    var bucket = /* Cons */[\n      key,\n      info,\n      bucket_002\n    ];\n    Caml_array.caml_array_set(h[/* data */1], i, bucket);\n    h[/* size */0] = h[/* size */0] + 1 | 0;\n    if (h[/* size */0] > (h[/* data */1].length << 1)) {\n      return resize(key_index, h);\n    } else {\n      return 0;\n    }\n  };\n  var remove = function (h, key) {\n    var remove_bucket = function (param) {\n      if (param) {\n        var next = param[2];\n        var k = param[0];\n        if (Curry._2(equal, k, key)) {\n          h[/* size */0] = h[/* size */0] - 1 | 0;\n          return next;\n        } else {\n          return /* Cons */[\n                  k,\n                  param[1],\n                  remove_bucket(next)\n                ];\n        }\n      } else {\n        return /* Empty */0;\n      }\n    };\n    var i = key_index(h, key);\n    return Caml_array.caml_array_set(h[/* data */1], i, remove_bucket(Caml_array.caml_array_get(h[/* data */1], i)));\n  };\n  var find = function (h, key) {\n    var match = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n    if (match) {\n      var rest1 = match[2];\n      if (Curry._2(equal, key, match[0])) {\n        return match[1];\n      } else if (rest1) {\n        var rest2 = rest1[2];\n        if (Curry._2(equal, key, rest1[0])) {\n          return rest1[1];\n        } else if (rest2) {\n          if (Curry._2(equal, key, rest2[0])) {\n            return rest2[1];\n          } else {\n            var key$1 = key;\n            var _param = rest2[2];\n            while(true) {\n              var param = _param;\n              if (param) {\n                if (Curry._2(equal, key$1, param[0])) {\n                  return param[1];\n                } else {\n                  _param = param[2];\n                  continue ;\n                  \n                }\n              } else {\n                throw Caml_builtin_exceptions.not_found;\n              }\n            };\n          }\n        } else {\n          throw Caml_builtin_exceptions.not_found;\n        }\n      } else {\n        throw Caml_builtin_exceptions.not_found;\n      }\n    } else {\n      throw Caml_builtin_exceptions.not_found;\n    }\n  };\n  var find_all = function (h, key) {\n    var find_in_bucket = function (_param) {\n      while(true) {\n        var param = _param;\n        if (param) {\n          var rest = param[2];\n          if (Curry._2(equal, param[0], key)) {\n            return /* :: */[\n                    param[1],\n                    find_in_bucket(rest)\n                  ];\n          } else {\n            _param = rest;\n            continue ;\n            \n          }\n        } else {\n          return /* [] */0;\n        }\n      };\n    };\n    return find_in_bucket(Caml_array.caml_array_get(h[/* data */1], key_index(h, key)));\n  };\n  var replace = function (h, key, info) {\n    var replace_bucket = function (param) {\n      if (param) {\n        var next = param[2];\n        var k = param[0];\n        if (Curry._2(equal, k, key)) {\n          return /* Cons */[\n                  key,\n                  info,\n                  next\n                ];\n        } else {\n          return /* Cons */[\n                  k,\n                  param[1],\n                  replace_bucket(next)\n                ];\n        }\n      } else {\n        throw Caml_builtin_exceptions.not_found;\n      }\n    };\n    var i = key_index(h, key);\n    var l = Caml_array.caml_array_get(h[/* data */1], i);\n    try {\n      return Caml_array.caml_array_set(h[/* data */1], i, replace_bucket(l));\n    }\n    catch (exn){\n      if (exn === Caml_builtin_exceptions.not_found) {\n        Caml_array.caml_array_set(h[/* data */1], i, /* Cons */[\n              key,\n              info,\n              l\n            ]);\n        h[/* size */0] = h[/* size */0] + 1 | 0;\n        if (h[/* size */0] > (h[/* data */1].length << 1)) {\n          return resize(key_index, h);\n        } else {\n          return 0;\n        }\n      } else {\n        throw exn;\n      }\n    }\n  };\n  var mem = function (h, key) {\n    var _param = Caml_array.caml_array_get(h[/* data */1], key_index(h, key));\n    while(true) {\n      var param = _param;\n      if (param) {\n        if (Curry._2(equal, param[0], key)) {\n          return /* true */1;\n        } else {\n          _param = param[2];\n          continue ;\n          \n        }\n      } else {\n        return /* false */0;\n      }\n    };\n  };\n  var create$1 = function (sz) {\n    return create(/* Some */[/* false */0], sz);\n  };\n  return /* module */[\n          /* create */create$1,\n          /* clear */clear,\n          /* reset */reset,\n          /* copy */copy,\n          /* add */add,\n          /* remove */remove,\n          /* find */find,\n          /* find_all */find_all,\n          /* replace */replace,\n          /* mem */mem,\n          /* iter */iter,\n          /* fold */fold,\n          /* length */length,\n          /* stats */stats\n        ];\n}\n\nvar seeded_hash_param = Caml_hash.caml_hash;\n\nexports.create            = create;\nexports.clear             = clear;\nexports.reset             = reset;\nexports.copy              = copy;\nexports.add               = add;\nexports.find              = find;\nexports.find_all          = find_all;\nexports.mem               = mem;\nexports.remove            = remove;\nexports.replace           = replace;\nexports.iter              = iter;\nexports.fold              = fold;\nexports.length            = length;\nexports.randomize         = randomize;\nexports.stats             = stats;\nexports.Make              = Make;\nexports.MakeSeeded        = MakeSeeded;\nexports.hash              = hash;\nexports.seeded_hash       = seeded_hash;\nexports.hash_param        = hash_param;\nexports.seeded_hash_param = seeded_hash_param;\n/* No side effect */\n"},"hash":"e7545c77ff120f6647e7bbc1b82166f3"}